<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PNGé€éã‚°ãƒªãƒƒãƒã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ„ãƒ¼ãƒ«</title>
    <script src="./gif.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
        }

        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 30px;
            font-size: 2.5rem;
            background: linear-gradient(45deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .upload-area {
            border: 3px dashed #667eea;
            border-radius: 15px;
            padding: 40px;
            text-align: center;
            margin-bottom: 30px;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .upload-area:hover {
            border-color: #764ba2;
            background: rgba(102, 126, 234, 0.05);
        }

        .upload-area.dragover {
            border-color: #764ba2;
            background: rgba(102, 126, 234, 0.1);
        }

        .upload-text {
            font-size: 1.2rem;
            color: #666;
            margin-bottom: 15px;
        }

        .file-input {
            display: none;
        }

        .upload-btn {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 25px;
            font-size: 1rem;
            cursor: pointer;
            transition: transform 0.2s ease;
        }

        .upload-btn:hover {
            transform: translateY(-2px);
        }

        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .control-group {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 15px;
            border-left: 4px solid #667eea;
        }

        .control-group h3 {
            color: #333;
            margin-bottom: 15px;
            font-size: 1.1rem;
        }

        .slider-container {
            margin-bottom: 15px;
        }

        .slider-container label {
            display: block;
            margin-bottom: 5px;
            color: #555;
            font-weight: 500;
        }

        .slider {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #ddd;
            outline: none;
            -webkit-appearance: none;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(45deg, #667eea, #764ba2);
            cursor: pointer;
        }

        .slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(45deg, #667eea, #764ba2);
            cursor: pointer;
            border: none;
        }

        .value-display {
            display: inline-block;
            margin-left: 10px;
            font-weight: bold;
            color: #667eea;
        }

        .preview-section {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }

        .preview-container {
            text-align: center;
        }

        .preview-container h3 {
            margin-bottom: 15px;
            color: #333;
        }

        .canvas-container {
            border: 2px solid #ddd;
            border-radius: 10px;
            padding: 20px;
            background: 
                linear-gradient(45deg, #f0f0f0 25%, transparent 25%), 
                linear-gradient(-45deg, #f0f0f0 25%, transparent 25%), 
                linear-gradient(45deg, transparent 75%, #f0f0f0 75%), 
                linear-gradient(-45deg, transparent 75%, #f0f0f0 75%);
            background-size: 20px 20px;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
            min-height: 300px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        canvas {
            max-width: 100%;
            max-height: 400px;
            border-radius: 5px;
        }

        .action-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .btn {
            padding: 12px 25px;
            border: none;
            border-radius: 25px;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 500;
        }

        .btn-primary {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
        }

        .btn-secondary {
            background: linear-gradient(45deg, #28a745, #20c997);
            color: white;
        }

        .btn-danger {
            background: linear-gradient(45deg, #dc3545, #fd7e14);
            color: white;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .progress-container {
            margin: 20px 0;
            display: none;
        }

        .progress-bar {
            width: 100%;
            height: 10px;
            background: #ddd;
            border-radius: 5px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(45deg, #667eea, #764ba2);
            width: 0%;
            transition: width 0.3s ease;
        }

        .status-text {
            text-align: center;
            margin-top: 10px;
            color: #666;
        }

        .gif-info {
            background: #e3f2fd;
            border: 1px solid #2196f3;
            border-radius: 10px;
            padding: 15px;
            margin: 20px 0;
            text-align: center;
            color: #1976d2;
            font-size: 0.9rem;
        }

        @media (max-width: 768px) {
            .preview-section {
                grid-template-columns: 1fr;
            }
            
            .controls {
                grid-template-columns: 1fr;
            }
            
            h1 {
                font-size: 2rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ¨ PNGé€éã‚°ãƒªãƒƒãƒã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ„ãƒ¼ãƒ«</h1>
        
        <div class="upload-area" id="uploadArea">
            <div class="upload-text">PNGç”»åƒã‚’ãƒ‰ãƒ©ãƒƒã‚°&ãƒ‰ãƒ­ãƒƒãƒ— ã¾ãŸã¯ ã‚¯ãƒªãƒƒã‚¯ã—ã¦é¸æŠ</div>
            <button class="upload-btn" id="uploadButton">
                ğŸ“ ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠ
            </button>
            <input type="file" id="fileInput" class="file-input" accept="image/png" />
        </div>

        <div class="controls">
            <div class="control-group">
                <h3>ğŸŒªï¸ ã‚°ãƒªãƒƒãƒåŠ¹æœ</h3>
                <div class="slider-container">
                    <label for="glitchIntensity">å¼·åº¦: <span class="value-display" id="glitchValue">50</span></label>
                    <input type="range" id="glitchIntensity" class="slider" min="0" max="100" value="50">
                </div>
                <div class="slider-container">
                    <label for="glitchSpeed">é€Ÿåº¦: <span class="value-display" id="glitchSpeedValue">5</span></label>
                    <input type="range" id="glitchSpeed" class="slider" min="1" max="10" value="5">
                </div>
            </div>

            <div class="control-group">
                <h3>ğŸ“º ãƒã‚¤ã‚ºåŠ¹æœ</h3>
                <div class="slider-container">
                    <label for="noiseIntensity">å¼·åº¦: <span class="value-display" id="noiseValue">30</span></label>
                    <input type="range" id="noiseIntensity" class="slider" min="0" max="100" value="30">
                </div>
                <div class="slider-container">
                    <label for="noiseSize">ç²’å­ã‚µã‚¤ã‚º: <span class="value-display" id="noiseSizeValue">2</span></label>
                    <input type="range" id="noiseSize" class="slider" min="1" max="5" value="2">
                </div>
            </div>

            <div class="control-group">
                <h3>ğŸŒˆ è‰²ãšã‚ŒåŠ¹æœ</h3>
                <div class="slider-container">
                    <label for="colorShift">å¼·åº¦: <span class="value-display" id="colorShiftValue">20</span></label>
                    <input type="range" id="colorShift" class="slider" min="0" max="50" value="20">
                </div>
                <div class="slider-container">
                    <label for="colorSpeed">å¤‰åŒ–é€Ÿåº¦: <span class="value-display" id="colorSpeedValue">3</span></label>
                    <input type="range" id="colorSpeed" class="slider" min="1" max="10" value="3">
                </div>
            </div>

            <div class="control-group">
                <h3>âš™ï¸ ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³è¨­å®š</h3>
                <div class="slider-container">
                    <label for="frameRate">ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¬ãƒ¼ãƒˆ: <span class="value-display" id="frameRateValue">10</span> FPS</label>
                    <input type="range" id="frameRate" class="slider" min="5" max="30" value="10">
                </div>
                <div class="slider-container">
                    <label for="duration">ç¶™ç¶šæ™‚é–“: <span class="value-display" id="durationValue">2</span> ç§’</label>
                    <input type="range" id="duration" class="slider" min="1" max="10" value="2">
                </div>
            </div>
        </div>

        <div class="preview-section">
            <div class="preview-container">
                <h3>ğŸ“· å…ƒç”»åƒ</h3>
                <div class="canvas-container">
                    <canvas id="originalCanvas"></canvas>
                </div>
            </div>
            <div class="preview-container">
                <h3>âœ¨ ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼</h3>
                <div class="canvas-container">
                    <canvas id="previewCanvas"></canvas>
                </div>
            </div>
        </div>

        <div class="progress-container" id="progressContainer">
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill"></div>
            </div>
            <div class="status-text" id="statusText">å‡¦ç†ä¸­...</div>
        </div>

        <div class="action-buttons">
            <button class="btn btn-secondary" id="gifBtn" disabled>
                ğŸ¬ GIFç”Ÿæˆ
            </button>
            <button class="btn btn-primary" id="saveBtn" disabled style="display: none;">
                ğŸ’¾ ä¿å­˜
            </button>
        </div>

        <div class="gif-info" id="gifInfo" style="display: none;">
            ğŸ’¡ GIFç”Ÿæˆå®Œäº†ï¼ä¿å­˜ãƒœã‚¿ãƒ³ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã—ã¦ãã ã•ã„ã€‚
        </div>
    </div>

    <script>
        class GlitchAnimationTool {
            constructor() {
                this.originalImage = null;
                this.originalCanvas = document.getElementById('originalCanvas');
                this.previewCanvas = document.getElementById('previewCanvas');
                this.originalCtx = this.originalCanvas.getContext('2d', { willReadFrequently: true });
                this.previewCtx = this.previewCanvas.getContext('2d', { willReadFrequently: true });
                this.animationId = null;
                this.isGenerating = false;
                this.frameCount = 0;
                this.generatedGifBlob = null;
                this.originalAlphaData = null; // å…ƒç”»åƒã®ã‚¢ãƒ«ãƒ•ã‚¡ãƒãƒ£ãƒ³ãƒãƒ«ã‚’ä¿å­˜
                
                this.initializeEventListeners();
                this.initializeSliders();
            }

            initializeEventListeners() {
                const fileInput = document.getElementById('fileInput');
                const uploadArea = document.getElementById('uploadArea');
                const uploadButton = document.getElementById('uploadButton');
                
                fileInput.addEventListener('change', (e) => {
                    if (e.target.files && e.target.files.length > 0) {
                        this.loadImage(e.target.files[0]);
                    }
                });
                
                uploadButton.addEventListener('click', () => {
                    fileInput.click();
                });
                
                uploadArea.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    uploadArea.classList.add('dragover');
                });
                
                uploadArea.addEventListener('dragleave', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    uploadArea.classList.remove('dragover');
                });
                
                uploadArea.addEventListener('drop', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    uploadArea.classList.remove('dragover');
                    
                    const files = e.dataTransfer.files;
                    if (files && files.length > 0) {
                        this.loadImage(files[0]);
                    }
                });

                document.getElementById('gifBtn').addEventListener('click', () => this.generateGIF());
                document.getElementById('saveBtn').addEventListener('click', () => this.saveGIF());
            }

            initializeSliders() {
                const sliders = [
                    { id: 'glitchIntensity', display: 'glitchValue' },
                    { id: 'glitchSpeed', display: 'glitchSpeedValue' },
                    { id: 'noiseIntensity', display: 'noiseValue' },
                    { id: 'noiseSize', display: 'noiseSizeValue' },
                    { id: 'colorShift', display: 'colorShiftValue' },
                    { id: 'colorSpeed', display: 'colorSpeedValue' },
                    { id: 'frameRate', display: 'frameRateValue', suffix: ' FPS' },
                    { id: 'duration', display: 'durationValue', suffix: ' ç§’' }
                ];

                sliders.forEach(slider => {
                    const element = document.getElementById(slider.id);
                    const display = document.getElementById(slider.display);
                    
                    element.addEventListener('input', () => {
                        display.textContent = element.value + (slider.suffix || '');
                    });
                });
            }

            loadImage(file) {
                if (!file.type.includes('png')) {
                    alert('PNGç”»åƒã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚');
                    return;
                }

                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        // ç”»åƒã‚µã‚¤ã‚ºãƒã‚§ãƒƒã‚¯
                        if (img.width > 2000 || img.height > 2000) {
                            alert('ç”»åƒãŒå¤§ãã™ãã¾ã™ã€‚å¹…ã¾ãŸã¯é«˜ã•ãŒ2000ãƒ”ã‚¯ã‚»ãƒ«ä»¥ä¸‹ã®ç”»åƒã‚’ä½¿ç”¨ã—ã¦ãã ã•ã„ã€‚');
                            return;
                        }
                        this.originalImage = img;
                        this.setupCanvases();
                        this.enableControls();
                    };
                    img.onerror = () => {
                        alert('ç”»åƒã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚åˆ¥ã®PNGç”»åƒã‚’è©¦ã—ã¦ãã ã•ã„ã€‚');
                    };
                    img.src = e.target.result;
                };
                reader.onerror = () => {
                    alert('ãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚');
                };
                reader.readAsDataURL(file);
            }

            setupCanvases() {
                const { width, height } = this.originalImage;

                [this.originalCanvas, this.previewCanvas].forEach(canvas => {
                    canvas.width = width;
                    canvas.height = height;
                    canvas.style.maxWidth = '100%';
                    canvas.style.maxHeight = '400px';
                    canvas.style.objectFit = 'contain';
                });

                this.originalCtx.drawImage(this.originalImage, 0, 0, width, height);
                this.previewCtx.drawImage(this.originalImage, 0, 0, width, height);

                // å…ƒç”»åƒã®ã‚¢ãƒ«ãƒ•ã‚¡ãƒãƒ£ãƒ³ãƒãƒ«ã‚’ä¿å­˜
                const imageData = this.originalCtx.getImageData(0, 0, width, height);
                this.originalAlphaData = new Uint8ClampedArray(imageData.data.length / 4);
                for (let i = 0; i < imageData.data.length; i += 4) {
                    this.originalAlphaData[i / 4] = imageData.data[i + 3];
                }
                
                setTimeout(() => {
                    this.startPreview();
                }, 100);
            }

            enableControls() {
                document.getElementById('gifBtn').disabled = false;
            }

            startPreview() {
                if (this.animationId) {
                    this.stopAnimation();
                }
                
                this.frameCount = 0;
                this.animate();
            }

            animate() {
                if (!this.originalImage) return;
                
                this.applyEffects();
                this.frameCount++;
                
                const frameRate = parseInt(document.getElementById('frameRate').value);
                this.animationId = requestAnimationFrame(() => {
                    setTimeout(() => {
                        this.animate();
                    }, 1000 / frameRate);
                });
            }

            applyEffects() {
                const canvas = this.previewCanvas;
                const ctx = this.previewCtx;
                const { width, height } = canvas;

                ctx.clearRect(0, 0, width, height);
                ctx.drawImage(this.originalImage, 0, 0, width, height);

                const imageData = ctx.getImageData(0, 0, width, height);
                const data = imageData.data;

                const glitchIntensity = parseInt(document.getElementById('glitchIntensity').value);
                const glitchSpeed = parseInt(document.getElementById('glitchSpeed').value);
                const noiseIntensity = parseInt(document.getElementById('noiseIntensity').value);
                const noiseSize = parseInt(document.getElementById('noiseSize').value);
                const colorShift = parseInt(document.getElementById('colorShift').value);
                const colorSpeed = parseInt(document.getElementById('colorSpeed').value);

                if (glitchIntensity > 0) {
                    this.applyGlitchEffect(data, width, height, glitchIntensity, glitchSpeed);
                }

                if (noiseIntensity > 0) {
                    this.applyNoiseEffect(data, width, height, noiseIntensity, noiseSize);
                }

                if (colorShift > 0) {
                    this.applyColorShiftEffect(data, width, height, colorShift, colorSpeed);
                }

                // å…ƒç”»åƒã®ã‚¢ãƒ«ãƒ•ã‚¡ãƒãƒ£ãƒ³ãƒãƒ«ã‚’é©ç”¨
                this.applyAlphaMask(data, width, height);

                ctx.putImageData(imageData, 0, 0);
            }

            applyGlitchEffect(data, width, height, intensity, speed) {
                const time = this.frameCount * speed * 0.1;
                const glitchAmount = Math.sin(time) * intensity * 0.01;
                
                for (let y = 0; y < height; y++) {
                    if (Math.random() < intensity * 0.001) {
                        const offset = Math.floor(Math.sin(time + y * 0.1) * glitchAmount * width);
                        const sourceY = Math.max(0, Math.min(height - 1, y + Math.floor(Math.random() * 10 - 5)));
                        
                        for (let x = 0; x < width; x++) {
                            const sourceX = (x + offset + width) % width;
                            const sourceIndex = (sourceY * width + sourceX) * 4;
                            const targetIndex = (y * width + x) * 4;
                            
                            data[targetIndex] = data[sourceIndex];
                            data[targetIndex + 1] = data[sourceIndex + 1];
                            data[targetIndex + 2] = data[sourceIndex + 2];
                            // ã‚¢ãƒ«ãƒ•ã‚¡å€¤ã¯å¾Œã§ãƒã‚¹ã‚¯é©ç”¨
                        }
                    }
                }
            }

            applyNoiseEffect(data, width, height, intensity, size) {
                for (let y = 0; y < height; y += size) {
                    for (let x = 0; x < width; x += size) {
                        if (Math.random() < intensity * 0.01) {
                            const noise = Math.random() * 255;
                            
                            for (let dy = 0; dy < size && y + dy < height; dy++) {
                                for (let dx = 0; dx < size && x + dx < width; dx++) {
                                    const index = ((y + dy) * width + (x + dx)) * 4;
                                    
                                    data[index] = Math.min(255, data[index] + noise * 0.3);
                                    data[index + 1] = Math.min(255, data[index + 1] + noise * 0.3);
                                    data[index + 2] = Math.min(255, data[index + 2] + noise * 0.3);
                                    // ã‚¢ãƒ«ãƒ•ã‚¡å€¤ã¯å¾Œã§ãƒã‚¹ã‚¯é©ç”¨
                                }
                            }
                        }
                    }
                }
            }

            applyColorShiftEffect(data, width, height, shift, speed) {
                const time = this.frameCount * speed * 0.1;
                const rShift = Math.sin(time) * shift;
                const gShift = Math.sin(time + Math.PI * 0.66) * shift;
                const bShift = Math.sin(time + Math.PI * 1.33) * shift;

                const tempData = new Uint8ClampedArray(data);

                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const index = (y * width + x) * 4;
                        
                        const rX = Math.max(0, Math.min(width - 1, x + Math.floor(rShift)));
                        const rIndex = (y * width + rX) * 4;
                        data[index] = tempData[rIndex];

                        const gX = Math.max(0, Math.min(width - 1, x + Math.floor(gShift)));
                        const gIndex = (y * width + gX) * 4;
                        data[index + 1] = tempData[gIndex + 1];

                        const bX = Math.max(0, Math.min(width - 1, x + Math.floor(bShift)));
                        const bIndex = (y * width + bX) * 4;
                        data[index + 2] = tempData[bIndex + 2];

                        // ã‚¢ãƒ«ãƒ•ã‚¡å€¤ã¯å¾Œã§ãƒã‚¹ã‚¯é©ç”¨
                    }
                }
            }

            applyAlphaMask(data, width, height) {
                if (!this.originalAlphaData) {
                    console.error('å…ƒç”»åƒã®ã‚¢ãƒ«ãƒ•ã‚¡ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“');
                    return;
                }
                for (let i = 0; i < data.length / 4; i++) {
                    data[i * 4 + 3] = this.originalAlphaData[i];
                }
            }

            stopAnimation() {
                if (this.animationId) {
                    cancelAnimationFrame(this.animationId);
                    this.animationId = null;
                }
            }

            applyGlitchEffectToData(data, width, height, intensity, speed, frameNumber) {
                const time = frameNumber * speed * 0.1;
                const glitchAmount = Math.sin(time) * intensity * 0.01;
                
                for (let y = 0; y < height; y++) {
                    if (Math.random() < intensity * 0.001) {
                        const offset = Math.floor(Math.sin(time + y * 0.1) * glitchAmount * width);
                        const sourceY = Math.max(0, Math.min(height - 1, y + Math.floor(Math.random() * 10 - 5)));
                        
                        for (let x = 0; x < width; x++) {
                            const sourceX = (x + offset + width) % width;
                            const sourceIndex = (sourceY * width + sourceX) * 4;
                            const targetIndex = (y * width + x) * 4;
                            
                            data[targetIndex] = data[sourceIndex];
                            data[targetIndex + 1] = data[sourceIndex + 1];
                            data[targetIndex + 2] = data[sourceIndex + 2];
                            // ã‚¢ãƒ«ãƒ•ã‚¡å€¤ã¯å¾Œã§ãƒã‚¹ã‚¯é©ç”¨
                        }
                    }
                }
            }

            applyNoiseEffectToData(data, width, height, intensity, size, frameNumber) {
                for (let y = 0; y < height; y += size) {
                    for (let x = 0; x < width; x += size) {
                        if (Math.random() < intensity * 0.01) {
                            const noise = Math.random() * 255;
                            
                            for (let dy = 0; dy < size && y + dy < height; dy++) {
                                for (let dx = 0; dx < size && x + dx < width; dx++) {
                                    const index = ((y + dy) * width + (x + dx)) * 4;
                                    
                                    data[index] = Math.min(255, data[index] + noise * 0.3);
                                    data[index + 1] = Math.min(255, data[index + 1] + noise * 0.3);
                                    data[index + 2] = Math.min(255, data[index + 2] + noise * 0.3);
                                    // ã‚¢ãƒ«ãƒ•ã‚¡å€¤ã¯å¾Œã§ãƒã‚¹ã‚¯é©ç”¨
                                }
                            }
                        }
                    }
                }
            }

            applyColorShiftEffectToData(data, width, height, shift, speed, frameNumber) {
                const time = frameNumber * speed * 0.1;
                const rShift = Math.sin(time) * shift;
                const gShift = Math.sin(time + Math.PI * 0.66) * shift;
                const bShift = Math.sin(time + Math.PI * 1.33) * shift;

                const tempData = new Uint8ClampedArray(data);

                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const index = (y * width + x) * 4;
                        
                        const rX = Math.max(0, Math.min(width - 1, x + Math.floor(rShift)));
                        const rIndex = (y * width + rX) * 4;
                        data[index] = tempData[rIndex];

                        const gX = Math.max(0, Math.min(width - 1, x + Math.floor(gShift)));
                        const gIndex = (y * width + gX) * 4;
                        data[index + 1] = tempData[gIndex + 1];

                        const bX = Math.max(0, Math.min(width - 1, x + Math.floor(bShift)));
                        const bIndex = (y * width + bX) * 4;
                        data[index + 2] = tempData[bIndex + 2];

                        // ã‚¢ãƒ«ãƒ•ã‚¡å€¤ã¯å¾Œã§ãƒã‚¹ã‚¯é©ç”¨
                    }
                }
            }

            async generateGIF() {
                if (this.isGenerating) return;
                
                this.isGenerating = true;
                
                const progressContainer = document.getElementById('progressContainer');
                const progressFill = document.getElementById('progressFill');
                const statusText = document.getElementById('statusText');
                const gifInfo = document.getElementById('gifInfo');
                
                progressContainer.style.display = 'block';
                document.getElementById('gifBtn').disabled = true;
                
                try {
                    statusText.textContent = 'é€éã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³GIFã‚’ç”Ÿæˆä¸­...';
                    
                    const frameRate = parseInt(document.getElementById('frameRate').value);
                    const duration = parseInt(document.getElementById('duration').value);
                    const totalFrames = Math.min(frameRate * duration, 30); // æœ€å¤§30ãƒ•ãƒ¬ãƒ¼ãƒ 
                    const delay = Math.floor(1000 / frameRate);
                    
                    const gifCanvas = document.createElement('canvas');
                    gifCanvas.width = this.originalImage.width;
                    gifCanvas.height = this.originalImage.height;
                    const gifCtx = gifCanvas.getContext('2d', { willReadFrequently: true, alpha: true });
                    
                    const gif = new GIF({
                        workers: 2,
                        quality: 10,
                        width: this.originalImage.width,
                        height: this.originalImage.height,
                        transparent: 0, // ã‚¢ãƒ«ãƒ•ã‚¡å€¤0ã‚’é€éã¨ã—ã¦æ‰±ã†
                        repeat: 0,
                        debug: true,
                        workerScript: './gif.worker.js' // ãƒªãƒã‚¸ãƒˆãƒªå†…ã®ãƒ¯ãƒ¼ã‚«ãƒ¼ã‚¹ã‚¯ãƒªãƒ—ãƒˆ
                    });

                    const glitchIntensity = parseInt(document.getElementById('glitchIntensity').value);
                    const glitchSpeed = parseInt(document.getElementById('glitchSpeed').value);
                    const noiseIntensity = parseInt(document.getElementById('noiseIntensity').value);
                    const noiseSize = parseInt(document.getElementById('noiseSize').value);
                    const colorShift = parseInt(document.getElementById('colorShift').value);
                    const colorSpeed = parseInt(document.getElementById('colorSpeed').value);

                    for (let frame = 0; frame < totalFrames; frame++) {
                        try {
                            gifCtx.clearRect(0, 0, gifCanvas.width, gifCanvas.height);
                            gifCtx.drawImage(this.originalImage, 0, 0);
                            
                            const imageData = gifCtx.getImageData(0, 0, gifCanvas.width, gifCanvas.height);
                            const data = imageData.data;

                            // ãƒ‡ãƒãƒƒã‚°: ã‚¢ãƒ«ãƒ•ã‚¡ãƒãƒ£ãƒ³ãƒãƒ«ã®ç¢ºèª
                            let hasTransparent = false;
                            for (let i = 3; i < data.length; i += 4) {
                                if (data[i] < 255) {
                                    hasTransparent = true;
                                    break;
                                }
                            }
                            console.log(`ãƒ•ãƒ¬ãƒ¼ãƒ  ${frame + 1}: é€éãƒ”ã‚¯ã‚»ãƒ«æ¤œå‡º = ${hasTransparent}`);

                            if (glitchIntensity > 0) {
                                this.applyGlitchEffectToData(data, gifCanvas.width, gifCanvas.height, glitchIntensity, glitchSpeed, frame);
                            }
                            if (noiseIntensity > 0) {
                                this.applyNoiseEffectToData(data, gifCanvas.width, gifCanvas.height, noiseIntensity, noiseSize, frame);
                            }
                            if (colorShift > 0) {
                                this.applyColorShiftEffectToData(data, gifCanvas.width, gifCanvas.height, colorShift, colorSpeed, frame);
                            }

                            // å…ƒç”»åƒã®ã‚¢ãƒ«ãƒ•ã‚¡ãƒãƒ£ãƒ³ãƒãƒ«ã‚’é©ç”¨
                            this.applyAlphaMask(data, gifCanvas.width, gifCanvas.height);

                            // ãƒ‡ãƒãƒƒã‚°: ãƒã‚¹ã‚¯é©ç”¨å¾Œã®ã‚¢ãƒ«ãƒ•ã‚¡ãƒãƒ£ãƒ³ãƒãƒ«ç¢ºèª
                            hasTransparent = false;
                            for (let i = 3; i < data.length; i += 4) {
                                if (data[i] < 255) {
                                    hasTransparent = true;
                                    break;
                                }
                            }
                            console.log(`ãƒ•ãƒ¬ãƒ¼ãƒ  ${frame + 1}: ãƒã‚¹ã‚¯é©ç”¨å¾Œã€é€éãƒ”ã‚¯ã‚»ãƒ« = ${hasTransparent}`);

                            gifCtx.putImageData(imageData, 0, 0);
                            gif.addFrame(gifCtx, { delay: delay, copy: true, dispose: 2 });
                            
                            const progress = (frame / totalFrames) * 50;
                            progressFill.style.width = progress + '%';
                            console.log(`ãƒ•ãƒ¬ãƒ¼ãƒ  ${frame + 1}/${totalFrames} å®Œäº†`);
                            await new Promise(resolve => setTimeout(resolve, 10));
                        } catch (frameError) {
                            console.error(`ãƒ•ãƒ¬ãƒ¼ãƒ  ${frame + 1} å‡¦ç†ã‚¨ãƒ©ãƒ¼:`, frameError);
                            continue; // ã‚¨ãƒ©ãƒ¼ãŒã‚ã£ã¦ã‚‚æ¬¡ã®ãƒ•ãƒ¬ãƒ¼ãƒ ã¸
                        }
                    }
                    
                    statusText.textContent = 'GIFãƒ•ã‚¡ã‚¤ãƒ«ã‚’ç”Ÿæˆä¸­...';
                    
                    gif.on('progress', (p) => {
                        const progress = 50 + (p * 50);
                        progressFill.style.width = progress + '%';
                    });

                    gif.on('finished', (blob) => {
                        console.log('GIFç”Ÿæˆå®Œäº†:', blob);
                        this.generatedGifBlob = blob;
                        progressContainer.style.display = 'none';
                        progressFill.style.width = '0%';
                        gifInfo.style.display = 'block';
                        statusText.textContent = 'GIFç”Ÿæˆå®Œäº†ï¼';
                        const saveBtn = document.getElementById('saveBtn');
                        saveBtn.style.display = 'inline-block';
                        saveBtn.disabled = false;
                        document.getElementById('gifBtn').disabled = false;
                        this.isGenerating = false;
                        setTimeout(() => {
                            gifInfo.style.display = 'none';
                        }, 5000);
                    });

                    gif.on('error', (error) => {
                        console.error('GIFç”Ÿæˆã‚¨ãƒ©ãƒ¼è©³ç´°:', error);
                        alert(`GIFç”Ÿæˆä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: ${error.message || error}`);
                        this.handleGifError();
                    });

                    gif.on('abort', () => {
                        console.error('GIFç”ŸæˆãŒä¸­æ–­ã•ã‚Œã¾ã—ãŸ');
                        alert('GIFç”ŸæˆãŒä¸­æ–­ã•ã‚Œã¾ã—ãŸã€‚');
                        this.handleGifError();
                    });

                    gif.render();
                    
                } catch (error) {
                    console.error('GIFç”Ÿæˆã‚¨ãƒ©ãƒ¼:', error);
                    alert(`GIFç”Ÿæˆä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: ${error.message || error}`);
                    this.handleGifError();
                }
            }

            handleGifError() {
                const progressContainer = document.getElementById('progressContainer');
                const progressFill = document.getElementById('progressFill');
                const statusText = document.getElementById('statusText');
                
                progressContainer.style.display = 'none';
                progressFill.style.width = '0%';
                statusText.textContent = '';
                
                this.isGenerating = false;
                document.getElementById('gifBtn').disabled = false;
            }

            saveGIF() {
                if (!this.generatedGifBlob) {
                    alert('ã¾ãšGIFã‚’ç”Ÿæˆã—ã¦ãã ã•ã„ã€‚');
                    return;
                }

                try {
                    const url = URL.createObjectURL(this.generatedGifBlob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `glitch-animation-${Date.now()}.gif`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    setTimeout(() => {
                        URL.revokeObjectURL(url);
                    }, 100);
                } catch (error) {
                    console.error('ä¿å­˜ã‚¨ãƒ©ãƒ¼:', error);
                    alert('ãƒ•ã‚¡ã‚¤ãƒ«ã®ä¿å­˜ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚');
                }
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            new GlitchAnimationTool();
        });
    </script>
</body>
</html>
